# C言語によるポリモフィズムの実装

# GCC のメモリレイアウト
GNU の C++ コンパイラは -fdump-class-hierarchy オプションを使うと、
vtable のメモリレイアウトをファイルに出力する。
```
Vtable for A
A::_ZTV1A: 4u entries
0     (int (*)(...))0
8     (int (*)(...))(& _ZTI1A)
16    (int (*)(...))__cxa_pure_virtual
24    (int (*)(...))A::bar

Class A
   size=16 align=8
   base size=12 base align=8
A (0x0x7fc2ca6fa5a0) 0
    vptr=((& A::_ZTV1A) + 16u)

Vtable for B
B::_ZTV1B: 4u entries
0     (int (*)(...))0
8     (int (*)(...))(& _ZTI1B)
16    (int (*)(...))B::foo
24    (int (*)(...))B::bar

Class B
   size=16 align=8
   base size=16 base align=8
B (0x0x7fc2ca58c340) 0
    vptr=((& B::_ZTV1B) + 16u)
  A (0x0x7fc2ca6fa600) 0
      primary-for B (0x0x7fc2ca58c340)

_ZTV1A, _ZTV1B の TV は Table of Virtual Function の略っぽい。
また、_ZTI1A, _ZTI1B の TI は Type Info の略らしい。
```
B のインスタンス b1 には vptr が追加されるが、そのアドレスは
B用の仮想関数テーブルの先頭から 16u (16 word)離れた
ところを指している。 A についても、仮想関数テーブルの
先頭アドレスと vptr に設定されるアドレスは 16u 離れている。
なんのための領域なのか、調査が必要。
==> 最初の１ワードは常に0,２ワード目は typeinfo らしい。
 - [C++ の仮想関数と VTable について](https://qiita.com/msmania/items/452d4fb4dec76207df87)


最初の１ワードは、オフセット。多重継承のときに使用される。
 -[C++ vtables - Part 1 - Basics ](https://shaharmike.com/cpp/vtable-part1/)
 -[C++ vtables - Part 2 - Multiple Inheritance ](https://shaharmike.com/cpp/vtable-part2/)
 -[ Finish the derived RECORD_TYPE – generate VTT](http://www.it610.com/article/5008795.htm)
 -[Dumping a C++ object's memory layout with Clang](https://eli.thegreenplace.net/2012/12/17/dumping-a-c-objects-memory-layout-with-clang)


# 基底クラスのデフォルト実装の呼び出し

派生クラスの上書きした関数内で、基底クラスのデフォルト実装を
呼び出したい場合がある。

これを実現する方法として、２通り考えられる。

 + 抽象操作(pure virtual)と同様に仮想関数テーブルを利用する
 + 基底クラスのデフォルト実装を直接呼び出す


## 抽象操作(pure virtual)と同様に仮想関数テーブルを利用する
 基底クラスに virtual な関数のデフォルト実装関数を定義し、
 仮想関数テーブルにデフォルト実装関数のアドレスを登録する。

 基底クラスで仮想関数を呼び出す場合には、仮想関数テーブルに
 登録されている関数を呼び出す。

 派生クラスでデフォルト実装を上書きする場合、上書きする関数を
 定義し、そのアドレスを仮想関数テーブルに登録する。

 派生クラスの仮想関数テーブルのメモリレイアウトは、
 基底クラスの仮想関数テーブルを含んでいる。
 しかし、仮想関数テーブルは、基底クラス用、派生クラス用に
 別のメモリ領域を使用する。抽象操作を持つクラスに対し、
 一つずつ仮想関数テーブルが 作られる。

基底クラス、派生クラスのインスタンスは、その先頭に
vpointer (仮想関数テーブルへのポインタ)を持っている。

基底クラスのコンストラクタで、vpointer は
基底クラスの仮想関数テーブルを指すように設定する。

派生クラスのコンストラクタは、まず基底クラスのコンストラクタを
呼び出す。この時点では、 vpointer は基底クラスの仮想関数テーブルを
指している。そこで、基底クラスのコンストラクタを呼び出した後、
vpointer が派生クラスの仮想関数テーブルを指すように設定し直す。

仮想関数が全て純粋仮想関数（デフォルトの実装を持たない）場合は
上記の方法でよいが、デフォルトの実装を持ち、派生クラスから
呼び出したい場合は、もう人工夫必要となる。

上記のように vpointer を単純に上書きすると、基底クラスの
仮想関数テーブルのアドレスが失われてしまい、
派生クラスの上書き関数内で基底クラスのデフォルト実装を
呼び出せなくなってしまう。

そこで、派生クラスに vpointer をもうひとつ追加し、基底クラスの
仮想関数テーブルのアドレスを退避できるようにする。
派生クラスのコンストラクタで、先頭の vpointer を上書きするまえに
もうひとつの vpointer に基底クラスの仮想関数テーブルのアドレスを
退避させる。その後で、先頭の vpointer を派生クラスの仮想関数テーブルのアドレスで
上書きする。

派生クラスの上書き関数内で、基底クラスのデフォルト実装を呼び出す場合、
２つめの vpointer に退避させておいた、基底クラスの仮想関数テーブルを
参照し、登録されているデフォルト実装関数を呼びだせばよい。
 
## 基底クラスのデフォルト実装を直接呼び出す
派生クラスのインスタンスに vpointer ひとつでも、
基底クラスのデフォルト実装を呼び出すことができる。
基底クラスの仮想関数テーブルを利用せず、直接呼びだせばよい。

基底クラスのデフォルト実装は、抽象操作の具象なので
基底クラスの公開ヘッダにはプロトタイプ宣言せず、
基底クラスの非公開ヘッダにプロトタイプ宣言する。
（前節の場合は、デフォルト実装関数を基底クラスしか
直接呼び出さないため、非公開ヘッダにもプロトタイプ宣言は
せず、実装ファイルに static キーワードをつけてファイルスコープとし、
プロトタイプ宣言する）


